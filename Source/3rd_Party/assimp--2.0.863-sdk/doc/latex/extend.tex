\hypertarget{materials_General}{}\section{General}\label{materials_General}
Or -\/ how to write your own loaders. It\textquotesingle{}s easy. You just need to implement the \#\+Assimp\+::\+Base\+Importer class, which defines a few abstract methods, register your loader, test it carefully, and provide test models for it.

O\+K, that sounds too easy \+:-\/). The whole procedure for a new loader merely looks like this\+:


\begin{DoxyItemize}
\item Create a header ({\ttfamily {\itshape Format\+Name}Importer.\+h}) and a unit ({\ttfamily {\itshape Format\+Name}Importer.\+cpp}) in the {\ttfamily $<$root$>$/code/} directory 
\item Add them to the following workspaces\+: vc8 and vc9 (the files are in the workspaces directory), C\+M\+A\+K\+E (code/\+C\+Make\+Lists.\+txt, create a new source group for your importer and put them also to A\+D\+D\+\_\+\+L\+I\+B\+R\+A\+R\+Y( assimp S\+H\+A\+R\+E\+D)) 
\item Include {\itshape Assimp\+P\+C\+H.\+h} -\/ this is the P\+C\+H file, and it includes already most Assimp-\/internal stuff.  
\item Open Importer.\+cpp and include your header just below the {\itshape (include\+\_\+new\+\_\+importers\+\_\+here)} line, guarded by a \#define 
\begin{DoxyCode}
\textcolor{preprocessor}{#if (!defined ASSIMP\_BUILD\_NO\_FormatName\_IMPORTER)}
    ...
#endif
\end{DoxyCode}
 Wrap the same guard around your .cpp!


\item Now advance to the {\itshape (register\+\_\+new\+\_\+importers\+\_\+here)} line in the Importer.\+cpp and register your importer there -\/ just like all the others do. 
\item Setup a suitable test environment (i.\+e. use Assimp\+View or your own application), make sure to enable the \#ai\+Process\+\_\+\+Validate\+Data\+Structure flag and enable verbose logging. That is, simply call before you import anything\+: 
\begin{DoxyCode}
DefaultLogger::create(\textcolor{stringliteral}{"AssimpLog.txt"},Logger::VERBOSE)
\end{DoxyCode}
  
\item Implement the Assimp\+::\+Base\+Importer\+::\+Can\+Read(), Assimp\+::\+Base\+Importer\+::\+Intern\+Read\+File() and Assimp\+::\+Base\+Importer\+::\+Get\+Extension\+List(). Just copy\textquotesingle{}n\textquotesingle{}paste the template from Appendix A and adapt it for your needs.  
\item For error handling, throw a dynamic allocated Import\+Error\+Exception (see Appendix A) for critical errors, and log errors, warnings, infos and debuginfos with Default\+Logger\+::get()-\/$>$\mbox{[}error, warn, debug, info\mbox{]}.  
\item Make sure the loader compiles against all build configurations on all supported platforms. This includes {\itshape -\/noboost}! To avoid problems, see the boost section on this page for a list of all \textquotesingle{}allowed\textquotesingle{} boost classes (again, this grew historically when we had to accept that boost is not T\+H\+A\+T widely spread that one could rely on it being available everywhere).  
\item Provide some {\itshape free} test models in {\ttfamily $<$root$>$/test/models/$<$Format\+Name$>$/} and credit their authors. Test files for a file format shouldn\textquotesingle{}t be too large ({\itshape $\sim$500 Ki\+B in total}), and not too repetive. Try to cover all format features with test data.  
\item Done! Please, share your loader that everyone can profit from it!  
\end{DoxyItemize}\hypertarget{extend_properties}{}\section{Properties}\label{extend_properties}
You can use properties to chance the behavior of you importer. In order to do so, you have to overide Base\+Importer\+::\+Setup\+Properties, and specify you custom properties in ai\+Config.\+h. Just have a look to the other A\+I\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+I\+M\+P\+O\+R\+T\+\_\+$\ast$ defines and you will understand, how it works.

The properties can be set with Importer\+::\+Set\+Property$\ast$$\ast$$\ast$() and can be accessed in your Setup\+Properties function with Importer\+::\+Get\+Property$\ast$$\ast$$\ast$(). You can store the properties as a member variable of your importer, they are thread safe.\hypertarget{extend_tnote}{}\section{Notes for text importers}\label{extend_tnote}

\begin{DoxyItemize}
\item Try to make your parser as flexible as possible. Don\textquotesingle{}t rely on particular layout, whitespace/tab style, except if the file format has a strict definition. 
\item Call Assimp\+::\+Base\+Importer\+::\+Convert\+To\+U\+T\+F8() before you parse anything to convert foreign encodings to U\+T\+F-\/8. That\textquotesingle{}s not necessary for X\+M\+L importers, which must use the provided Irr\+X\+M\+L for reading.  
\end{DoxyItemize}\hypertarget{extend_bnote}{}\section{Notes for binary importers}\label{extend_bnote}

\begin{DoxyItemize}
\item Take care of endianess issues! Assimp importers mostly support big-\/endian platforms, which define the {\ttfamily A\+I\+\_\+\+B\+U\+I\+L\+D\+\_\+\+B\+I\+G\+\_\+\+E\+N\+D\+I\+A\+N} constant. See the next section for a list of utilities to simplify this task.  
\item Don\textquotesingle{}t trust the input data! Check all offsets!  
\end{DoxyItemize}\hypertarget{extend_util}{}\section{Utilities}\label{extend_util}
Mixed stuff for internal use by loaders, mostly documented (most of them are already included by {\itshape Assimp\+P\+C\+H.\+h})\+: 
\begin{DoxyItemize}
\item {\bfseries Byte\+Swap} ({\itshape Byte\+Swap.\+h}) -\/ manual byte swapping stuff for binary loaders. 
\item {\bfseries Stream\+Reader} ({\itshape Stream\+Reader.\+h}) -\/ safe, endianess-\/correct, binary reading. 
\item {\bfseries Irr\+X\+M\+L} ({\itshape irr\+X\+M\+L\+Wrapper.\+h}) -\/ for X\+M\+L-\/parsing (S\+A\+X. 
\item {\bfseries Comment\+Remover} ({\itshape Remove\+Comments.\+h}) -\/ remove single-\/line and multi-\/line comments from a text file. 
\item fast\+\_\+atof, strtol10, strtol16, Skip\+Space\+And\+Line\+End, Skip\+To\+Next\+Token .. large family of low-\/level parsing functions, mostly declared in {\itshape fast\+\_\+atof.\+h}, {\itshape String\+Comparison.\+h} and {\itshape Parsing\+Utils.\+h} (a collection that grew historically, so don\textquotesingle{}t expect perfect organization).  
\item {\bfseries Compute\+Normals\+With\+Smoothings\+Groups()} ({\itshape Smoothing\+Groups.\+h}) -\/ Computes normal vectors from plain old smoothing groups.  
\item {\bfseries Skeleton\+Mesh\+Builder} ({\itshape Skeleton\+Mesh\+Builder.\+h}) -\/ generate a dummy mesh from a given (animation) skeleton.  
\item {\bfseries Standard\+Shapes} ({\itshape Standard\+Shapes.\+h}) -\/ generate meshes for standard solids, such as platonic primitives, cylinders or spheres.  
\item {\bfseries Batch\+Loader} ({\itshape Base\+Importer.\+h}) -\/ manage imports from external files. Useful for file formats which spread their data across multiple files.  
\item {\bfseries Scene\+Combiner} ({\itshape Scene\+Combiner.\+h}) -\/ exhaustive toolset to merge multiple scenes. Useful for file formats which spread their data across multiple files.  
\end{DoxyItemize}\hypertarget{extend_mat}{}\section{Filling materials}\label{extend_mat}
The required definitions zo set/remove/query keys in \#ai\+Material structures are declared in {\itshape Material\+System.\+h}, in a \#ai\+Material derivate called \#\+Assimp\+::\+Material\+Helper. The header is included by Assimp\+P\+C\+H.\+h, so you don\textquotesingle{}t need to bother.


\begin{DoxyCode}
MaterialHelper* mat = \textcolor{keyword}{new} MaterialHelper();

\textcolor{keyword}{const} \textcolor{keywordtype}{float} spec = 16.f;
mat->AddProperty(&spec, 1, AI\_MATKEY\_SHININESS);

\textcolor{comment}{//set the name of the material:}
NewMaterial->AddProperty(&aiString(MaterialName.c\_str()), AI\_MATKEY\_NAME);\textcolor{comment}{//MaterialName is a std::string}

\textcolor{comment}{//set the first diffuse texture}
NewMaterial->AddProperty(&aiString(Texturename.c\_str()), AI\_MATKEY\_TEXTURE(aiTextureType\_DIFFUSE, 0));\textcolor{comment}{//
      again, Texturename is a std::string}
\end{DoxyCode}
\hypertarget{extend_boost}{}\section{Boost}\label{extend_boost}
The boost whitelist\+: 
\begin{DoxyItemize}
\item {\itshape boost.\+scoped\+\_\+ptr} 
\item {\itshape boost.\+scoped\+\_\+array} 
\item {\itshape boost.\+format}  
\item {\itshape boost.\+random}  
\item {\itshape boost.\+common\+\_\+factor}  
\item {\itshape boost.\+foreach}  
\item {\itshape boost.\+tuple} 
\end{DoxyItemize}

(if you happen to need something else, i.\+e. boost\+::thread, make this an optional feature. {\ttfamily A\+S\+S\+I\+M\+P\+\_\+\+B\+U\+I\+L\+D\+\_\+\+B\+O\+O\+S\+T\+\_\+\+W\+O\+R\+K\+A\+R\+O\+U\+N\+D} is defined for {\itshape -\/noboost} builds)\hypertarget{extend_appa}{}\section{Appendix A -\/ Template for Base\+Importer\textquotesingle{}s abstract methods}\label{extend_appa}

\begin{DoxyCode}
\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{comment}{// Returns whether the class can handle the format of the given file. }
\textcolor{keywordtype}{bool} xxxxImporter::CanRead( \textcolor{keyword}{const} std::string& pFile, IOSystem* pIOHandler, 
    \textcolor{keywordtype}{bool} checkSig)\textcolor{keyword}{ const}
\textcolor{keyword}{}\{
    \textcolor{keyword}{const} std::string extension = GetExtension(pFile);
    \textcolor{keywordflow}{if}(extension == \textcolor{stringliteral}{"xxxx"}) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{if} (!extension.length() || checkSig) \{
        \textcolor{comment}{// no extension given, or we're called a second time because no }
        \textcolor{comment}{// suitable loader was found yet. This means, we're trying to open }
        \textcolor{comment}{// the file and look for and hints to identify the file format.}
        \textcolor{comment}{// #Assimp::BaseImporter provides some utilities:}
        \textcolor{comment}{//}
        \textcolor{comment}{// #Assimp::BaseImporter::SearchFileHeaderForToken - for text files.}
        \textcolor{comment}{// It reads the first lines of the file and does a substring check}
        \textcolor{comment}{// against a given list of 'magic' strings.}
        \textcolor{comment}{//}
        \textcolor{comment}{// #Assimp::BaseImporter::CheckMagicToken - for binary files. It goes}
        \textcolor{comment}{// to a particular offset in the file and and compares the next words }
        \textcolor{comment}{// against a given list of 'magic' tokens.}

        \textcolor{comment}{// These checks MUST be done (even if !checkSig) if the file extension }
        \textcolor{comment}{// is not exclusive to your format. For example, .xml is very common }
        \textcolor{comment}{// and (co)used by many formats.}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{comment}{// Get list of file extensions handled by this loader}
\textcolor{keywordtype}{void} xxxxImporter::GetExtensionList(std::set<std::string>& extensions)
\{
    extensions.insert(\textcolor{stringliteral}{"xxx"});
\}

\textcolor{comment}{// -------------------------------------------------------------------------------}
\textcolor{keywordtype}{void} xxxxImporter::InternReadFile( \textcolor{keyword}{const} std::string& pFile, 
    aiScene* pScene, IOSystem* pIOHandler)
\{
    boost::scoped\_ptr<IOStream> file( pIOHandler->Open( pFile, \textcolor{stringliteral}{"rb"}));

    \textcolor{comment}{// Check whether we can read from the file}
    \textcolor{keywordflow}{if}( file.get() == NULL) \{
        \textcolor{keywordflow}{throw} DeadlyImportError( \textcolor{stringliteral}{"Failed to open xxxx file "} + pFile + \textcolor{stringliteral}{"."});
    \}
    
    \textcolor{comment}{// Your task: fill pScene}
    \textcolor{comment}{// Throw a ImportErrorException with a meaningful (!) error message if }
    \textcolor{comment}{// something goes wrong.}
\}
\end{DoxyCode}
 