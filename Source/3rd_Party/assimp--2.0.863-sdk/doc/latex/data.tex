The A\+S\+S\+I\+M\+P library returns the imported data in a collection of structures. ai\+Scene forms the root of the data, from here you gain access to all the nodes, meshes, materials, animations or textures that were read from the imported file. The ai\+Scene is returned from a successful call to A\+S\+S\+I\+M\+P\+::\+Importer\+::\+Read\+File(), ai\+Import\+File() or ai\+Import\+File\+Ex() -\/ see the \hyperlink{usage}{Usage page } for further information on how to use the library.

By default, all 3\+D data is provided in a right-\/handed coordinate system such as Open\+G\+L uses. In this coordinate system, +\+X points to the right, -\/\+Z points away from the viewer into the screen and +\+Y points upwards. Several modeling packages such as 3\+D Studio Max use this coordinate system as well (or a rotated variant of it). By contrast, some other environments use left-\/handed coordinate systems, a prominent example being Direct\+X. If you need the imported data to be in a left-\/handed coordinate system, supply the \#ai\+Process\+\_\+\+Make\+Left\+Handed flag to the Read\+File() function call.

The output face winding is counter clockwise. Use \#ai\+Process\+\_\+\+Flip\+Winding\+Order to get C\+W data. 
\begin{DoxyCode}
x2
  
            x1
    x0
\end{DoxyCode}


Outputted polygons can be literally everything\+: they\textquotesingle{}re probably concave, self-\/intersecting or non-\/planar, although our built-\/in triangulation (\#ai\+Process\+\_\+\+Triangulate postprocessing step) doesn\textquotesingle{}t handle the two latter.

The output U\+V coordinate system has its origin in the lower-\/left corner\+: 
\begin{DoxyCode}
0y|1y ---------- 1x|1y 
 |                |
 |                |
 |                |
0x|0y ---------- 1x|0y
\end{DoxyCode}
 Use the \#ai\+Process\+\_\+\+Flip\+U\+Vs flag to get U\+V coordinates with the upper-\/left corner als origin.

All matrices in the library are row-\/major. That means that the matrices are stored row by row in memory, which is similar to the Open\+G\+L matrix layout. A typical 4x4 matrix including a translational part looks like this\+: 
\begin{DoxyCode}
X1  Y1  Z1  T1
X2  Y2  Z2  T2
X3  Y3  Z3  T3
0   0   0   1
\end{DoxyCode}


... with (X1, X2, X3) being the X base vector, (Y1, Y2, Y3) being the Y base vector, (Z1, Z2, Z3) being the Z base vector and (T1, T2, T3) being the translation part. If you want to use these matrices in Direct\+X functions, you have to transpose them.





{\bfseries 11.\+24.\+09\+:} We changed the orientation of our quaternions to the most common convention to avoid confusion. However, if you\textquotesingle{}re a previous user of Assimp and you update the library to revisions beyond S\+V\+N\+R\+E\+V 502, you have to adapt your animation loading code to match the new quaternion orientation.



\hypertarget{data_hierarchy}{}\section{The Node Hierarchy}\label{data_hierarchy}
Nodes are little named entities in the scene that have a place and orientation relative to their parents. Starting from the scene\textquotesingle{}s root node all nodes can have 0 to x child nodes, thus forming a hierarchy. They form the base on which the scene is built on\+: a node can refer to 0..x meshes, can be referred to by a bone of a mesh or can be animated by a key sequence of an animation. Direct\+X calls them \char`\"{}frames\char`\"{}, others call them \char`\"{}objects\char`\"{}, we call them ai\+Node.

A node can potentially refer to single or multiple meshes. The meshes are not stored inside the node, but instead in an array of ai\+Mesh inside the ai\+Scene. A node only refers to them by their array index. This also means that multiple nodes can refer to the same mesh, which provides a simple form of instancing. A mesh referred to by this way lives in the node\textquotesingle{}s local coordinate system. If you want the mesh\textquotesingle{}s orientation in global space, you\textquotesingle{}d have to concatenate the transformations from the referring node and all of its parents.

Most of the file formats don\textquotesingle{}t really support complex scenes, though, but a single model only. But there are more complex formats such as .3ds, .x or .collada scenes which may contain an arbitrary complex hierarchy of nodes and meshes. I for myself would suggest a recursive filter function such as the following pseudocode\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} CopyNodesWithMeshes( aiNode node, SceneObject targetParent, Matrix4x4 accTransform)
\{
  SceneObject parent;
  Matrix4x4 transform;

  \textcolor{comment}{// if node has meshes, create a new scene object for it}
  \textcolor{keywordflow}{if}( node.mNumMeshes > 0)
  \{
    SceneObjekt newObject = \textcolor{keyword}{new} SceneObject;
    targetParent.addChild( newObject);
    \textcolor{comment}{// copy the meshes}
    CopyMeshes( node, newObject);

    \textcolor{comment}{// the new object is the parent for all child nodes}
    parent = newObject;
    transform.SetUnity();
  \} \textcolor{keywordflow}{else}
  \{
    \textcolor{comment}{// if no meshes, skip the node, but keep its transformation}
    parent = targetParent;
    transform = node.mTransformation * accTransform;
  \}

  \textcolor{comment}{// continue for all child nodes}
  \textcolor{keywordflow}{for}( all node.mChildren)
    CopyNodesWithMeshes( node.mChildren[a], parent, transform);
\}
\end{DoxyCode}


This function copies a node into the scene graph if it has children. If yes, a new scene object is created for the import node and the node\textquotesingle{}s meshes are copied over. If not, no object is created. Potential child objects will be added to the old target\+Parent, but there transformation will be correct in respect to the global space. This function also works great in filtering the bone nodes -\/ nodes that form the bone hierarchy for another mesh/node, but don\textquotesingle{}t have any mesh themselves.\hypertarget{data_meshes}{}\section{Meshes}\label{data_meshes}
All meshes of an imported scene are stored in an array of ai\+Mesh$\ast$ inside the ai\+Scene. Nodes refer to them by their index in the array and providing the coordinate system for them, too. One mesh uses only a single material everywhere -\/ if parts of the model use a different material, this part is moved to a separate mesh at the same node. The mesh refers to its material in the same way as the node refers to its meshes\+: materials are stored in an array inside ai\+Scene, the mesh stores only an index into this array.

An ai\+Mesh is defined by a series of data channels. The presence of these data channels is defined by the contents of the imported file\+: by default there are only those data channels present in the mesh that were also found in the file. The only channels guarenteed to be always present are ai\+Mesh\+::m\+Vertices and ai\+Mesh\+::m\+Faces. You can test for the presence of other data by testing the pointers against N\+U\+L\+L or use the helper functions provided by ai\+Mesh. You may also specify several post processing flags at Importer\+::\+Read\+File() to let A\+S\+S\+I\+M\+P calculate or recalculate additional data channels for you.

At the moment, a single ai\+Mesh may contain a set of triangles and polygons. A single vertex does always have a position. In addition it may have one normal, one tangent and bitangent, zero to A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+T\+E\+X\+T\+U\+R\+E\+C\+O\+O\+R\+D\+S (4 at the moment) texture coords and zero to A\+I\+\_\+\+M\+A\+X\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+C\+O\+L\+O\+R\+\_\+\+S\+E\+T\+S (4) vertex colors. In addition a mesh may or may not have a set of bones described by an array of ai\+Bone structures. How to interpret the bone information is described later on.\hypertarget{importer_notes_material}{}\section{Materials}\label{importer_notes_material}
See the \hyperlink{materials}{Material System Page. }\hypertarget{data_bones}{}\section{Bones}\label{data_bones}
A mesh may have a set of bones in the form of ai\+Bone structures.. Bones are a means to deform a mesh according to the movement of a skeleton. Each bone has a name and a set of vertices on which it has influence. Its offset matrix declares the transformation needed to transform from mesh space to the local space of this bone.

Using the bones name you can find the corresponding node in the node hierarchy. This node in relation to the other bones\textquotesingle{} nodes defines the skeleton of the mesh. Unfortunately there might also be nodes which are not used by a bone in the mesh, but still affect the pose of the skeleton because they have child nodes which are bones. So when creating the skeleton hierarchy for a mesh I suggest the following method\+:

a) Create a map or a similar container to store which nodes are necessary for the skeleton. Pre-\/initialise it for all nodes with a \char`\"{}no\char`\"{}. ~\newline
 b) For each bone in the mesh\+: ~\newline
 b1) Find the corresponding node in the scene\textquotesingle{}s hierarchy by comparing their names. ~\newline
 b2) Mark this node as \char`\"{}yes\char`\"{} in the necessity\+Map. ~\newline
 b3) Mark all of its parents the same way until you 1) find the mesh\textquotesingle{}s node or 2) the parent of the mesh\textquotesingle{}s node. ~\newline
 c) Recursively iterate over the node hierarchy ~\newline
 c1) If the node is marked as necessary, copy it into the skeleton and check its children ~\newline
 c2) If the node is marked as not necessary, skip it and do not iterate over its children. ~\newline


Reasons\+: you need all the parent nodes to keep the transformation chain intact. Depending on the file format and the modelling package the node hierarchy of the skeleton is either a child of the mesh node or a sibling of the mesh node. Therefore b3) stops at both the mesh\textquotesingle{}s node and the mesh\textquotesingle{}s node\textquotesingle{}s parent. The node closest to the root node is your skeleton root, from there you start copying the hierarchy. You can skip every branch without a node being a bone in the mesh -\/ that\textquotesingle{}s why the algorithm skips the whole branch if the node is marked as \char`\"{}not necessary\char`\"{}.

You should now have a mesh in your engine with a skeleton that is a subset of the imported hierarchy.\hypertarget{data_anims}{}\section{Animations}\label{data_anims}
An imported scene may contain zero to x ai\+Animation entries. An animation in this context is a set of keyframe sequences where each sequence describes the orientation of a single node in the hierarchy over a limited time span. Animations of this kind are usually used to animate the skeleton of a skinned mesh, but there are other uses as well.

An ai\+Animation has a duration. The duration as well as all time stamps are given in ticks. To get the correct timing, all time stamp thus have to be divided by ai\+Animation\+::m\+Ticks\+Per\+Second. Beware, though, that certain combinations of file format and exporter don\textquotesingle{}t always store this information in the exported file. In this case, m\+Ticks\+Per\+Second is set to 0 to indicate the lack of knowledge.

The ai\+Animation consists of a series of ai\+Node\+Anim\textquotesingle{}s. Each bone animation affects a single node in the node hierarchy only, the name specifying which node is affected. For this node the structure stores three separate key sequences\+: a vector key sequence for the position, a quaternion key sequence for the rotation and another vector key sequence for the scaling. All 3d data is local to the coordinate space of the node\textquotesingle{}s parent, that means in the same space as the node\textquotesingle{}s transformation matrix. There might be cases where animation tracks refer to a non-\/existent node by their name, but this should not be the case in your every-\/day data.

To apply such an animation you need to identify the animation tracks that refer to actual bones in your mesh. Then for every track\+: ~\newline
 a) Find the keys that lay right before the current anim time. ~\newline
 b) Optional\+: interpolate between these and the following keys. ~\newline
 c) Combine the calculated position, rotation and scaling to a tranformation matrix ~\newline
 d) Set the affected node\textquotesingle{}s transformation to the calculated matrix. ~\newline


If you need hints on how to convert to or from quaternions, have a look at the \href{http://www.j3d.org/matrix_faq/matrfaq_latest.html}{\tt Matrix\&Quaternion F\+A\+Q}. I suggest using logarithmic interpolation for the scaling keys if you happen to need them -\/ usually you don\textquotesingle{}t need them at all.\hypertarget{data_textures}{}\section{Textures}\label{data_textures}
Normally textures used by assets are stored in separate files, however, there are file formats embedding their textures directly into the model file. Such textures are loaded into an ai\+Texture structure. ~\newline
 There are two cases\+: ~\newline
 {\bfseries 1)} The texture is N\+O\+T compressed. Its color data is directly stored in the ai\+Texture structure as an array of ai\+Texture\+::m\+Width $\ast$ ai\+Texture\+::m\+Height ai\+Texel structures. Each ai\+Texel represents a pixel (or \char`\"{}texel\char`\"{}) of the texture image. The color data is stored in an unsigned R\+G\+B\+A8888 format, which can be easily used for both Direct3\+D and Open\+G\+L (swizzling the order of the color components might be necessary). R\+G\+B\+A8888 has been chosen because it is well-\/known, easy to use and natively supported by nearly all graphics A\+P\+Is. ~\newline
 {\bfseries 2)} This applies if ai\+Texture\+::m\+Height == 0 is fullfilled. Then, texture is stored in a \char`\"{}compressed\char`\"{} format such as D\+D\+S or P\+N\+G. The term \char`\"{}compressed\char`\"{} does not mean that the texture data must actually be compressed, however the texture was found in the model file as if it was stored in a separate file on the harddisk. Appropriate decoders (such as libjpeg, libpng, D3\+D\+X, Dev\+I\+L) are required to load theses textures. ai\+Texture\+::m\+Width specifies the size of the texture data in bytes, ai\+Texture\+::pc\+Data is a pointer to the raw image data and ai\+Texture\+::ach\+Format\+Hint is either zeroed or contains the most common file extension of the embedded texture\textquotesingle{}s format. This value is only set if A\+S\+S\+I\+M\+P is able to determine the file format. 