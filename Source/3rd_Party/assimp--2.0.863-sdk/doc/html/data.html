<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Data Structures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The ASSIMP library returns the imported data in a collection of structures. aiScene forms the root of the data, from here you gain access to all the nodes, meshes, materials, animations or textures that were read from the imported file. The aiScene is returned from a successful call to ASSIMP::Importer::ReadFile(), aiImportFile() or aiImportFileEx() - see the <a class="el" href="usage.html">Usage page </a> for further information on how to use the library.</p>
<p>By default, all 3D data is provided in a right-handed coordinate system such as OpenGL uses. In this coordinate system, +X points to the right, -Z points away from the viewer into the screen and +Y points upwards. Several modeling packages such as 3D Studio Max use this coordinate system as well (or a rotated variant of it). By contrast, some other environments use left-handed coordinate systems, a prominent example being DirectX. If you need the imported data to be in a left-handed coordinate system, supply the #aiProcess_MakeLeftHanded flag to the ReadFile() function call.</p>
<p>The output face winding is counter clockwise. Use #aiProcess_FlipWindingOrder to get CW data. </p><div class="fragment"><div class="line">x2</div>
<div class="line">  </div>
<div class="line">            x1</div>
<div class="line">    x0</div>
</div><!-- fragment --><p>Outputted polygons can be literally everything: they're probably concave, self-intersecting or non-planar, although our built-in triangulation (#aiProcess_Triangulate postprocessing step) doesn't handle the two latter.</p>
<p>The output UV coordinate system has its origin in the lower-left corner: </p><div class="fragment"><div class="line">0y|1y ---------- 1x|1y </div>
<div class="line"> |                |</div>
<div class="line"> |                |</div>
<div class="line"> |                |</div>
<div class="line">0x|0y ---------- 1x|0y</div>
</div><!-- fragment --><p> Use the #aiProcess_FlipUVs flag to get UV coordinates with the upper-left corner als origin.</p>
<p>All matrices in the library are row-major. That means that the matrices are stored row by row in memory, which is similar to the OpenGL matrix layout. A typical 4x4 matrix including a translational part looks like this: </p><div class="fragment"><div class="line">X1  Y1  Z1  T1</div>
<div class="line">X2  Y2  Z2  T2</div>
<div class="line">X3  Y3  Z3  T3</div>
<div class="line">0   0   0   1</div>
</div><!-- fragment --><p>... with (X1, X2, X3) being the X base vector, (Y1, Y2, Y3) being the Y base vector, (Z1, Z2, Z3) being the Z base vector and (T1, T2, T3) being the translation part. If you want to use these matrices in DirectX functions, you have to transpose them.</p>
<hr/>
<p><b>11.24.09:</b> We changed the orientation of our quaternions to the most common convention to avoid confusion. However, if you're a previous user of Assimp and you update the library to revisions beyond SVNREV 502, you have to adapt your animation loading code to match the new quaternion orientation.</p>
<hr/>
<h1><a class="anchor" id="hierarchy"></a>
The Node Hierarchy</h1>
<p>Nodes are little named entities in the scene that have a place and orientation relative to their parents. Starting from the scene's root node all nodes can have 0 to x child nodes, thus forming a hierarchy. They form the base on which the scene is built on: a node can refer to 0..x meshes, can be referred to by a bone of a mesh or can be animated by a key sequence of an animation. DirectX calls them "frames", others call them "objects", we call them aiNode.</p>
<p>A node can potentially refer to single or multiple meshes. The meshes are not stored inside the node, but instead in an array of aiMesh inside the aiScene. A node only refers to them by their array index. This also means that multiple nodes can refer to the same mesh, which provides a simple form of instancing. A mesh referred to by this way lives in the node's local coordinate system. If you want the mesh's orientation in global space, you'd have to concatenate the transformations from the referring node and all of its parents.</p>
<p>Most of the file formats don't really support complex scenes, though, but a single model only. But there are more complex formats such as .3ds, .x or .collada scenes which may contain an arbitrary complex hierarchy of nodes and meshes. I for myself would suggest a recursive filter function such as the following pseudocode:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CopyNodesWithMeshes( aiNode node, SceneObject targetParent, Matrix4x4 accTransform)</div>
<div class="line">{</div>
<div class="line">  SceneObject parent;</div>
<div class="line">  Matrix4x4 transform;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if node has meshes, create a new scene object for it</span></div>
<div class="line">  <span class="keywordflow">if</span>( node.mNumMeshes &gt; 0)</div>
<div class="line">  {</div>
<div class="line">    SceneObjekt newObject = <span class="keyword">new</span> SceneObject;</div>
<div class="line">    targetParent.addChild( newObject);</div>
<div class="line">    <span class="comment">// copy the meshes</span></div>
<div class="line">    CopyMeshes( node, newObject);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the new object is the parent for all child nodes</span></div>
<div class="line">    parent = newObject;</div>
<div class="line">    transform.SetUnity();</div>
<div class="line">  } <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// if no meshes, skip the node, but keep its transformation</span></div>
<div class="line">    parent = targetParent;</div>
<div class="line">    transform = node.mTransformation * accTransform;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// continue for all child nodes</span></div>
<div class="line">  <span class="keywordflow">for</span>( all node.mChildren)</div>
<div class="line">    CopyNodesWithMeshes( node.mChildren[a], parent, transform);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function copies a node into the scene graph if it has children. If yes, a new scene object is created for the import node and the node's meshes are copied over. If not, no object is created. Potential child objects will be added to the old targetParent, but there transformation will be correct in respect to the global space. This function also works great in filtering the bone nodes - nodes that form the bone hierarchy for another mesh/node, but don't have any mesh themselves.</p>
<h1><a class="anchor" id="meshes"></a>
Meshes</h1>
<p>All meshes of an imported scene are stored in an array of aiMesh* inside the aiScene. Nodes refer to them by their index in the array and providing the coordinate system for them, too. One mesh uses only a single material everywhere - if parts of the model use a different material, this part is moved to a separate mesh at the same node. The mesh refers to its material in the same way as the node refers to its meshes: materials are stored in an array inside aiScene, the mesh stores only an index into this array.</p>
<p>An aiMesh is defined by a series of data channels. The presence of these data channels is defined by the contents of the imported file: by default there are only those data channels present in the mesh that were also found in the file. The only channels guarenteed to be always present are aiMesh::mVertices and aiMesh::mFaces. You can test for the presence of other data by testing the pointers against NULL or use the helper functions provided by aiMesh. You may also specify several post processing flags at Importer::ReadFile() to let ASSIMP calculate or recalculate additional data channels for you.</p>
<p>At the moment, a single aiMesh may contain a set of triangles and polygons. A single vertex does always have a position. In addition it may have one normal, one tangent and bitangent, zero to AI_MAX_NUMBER_OF_TEXTURECOORDS (4 at the moment) texture coords and zero to AI_MAX_NUMBER_OF_COLOR_SETS (4) vertex colors. In addition a mesh may or may not have a set of bones described by an array of aiBone structures. How to interpret the bone information is described later on.</p>
<h1><a class="anchor" id="material"></a>
Materials</h1>
<p>See the <a class="el" href="materials.html">Material System Page. </a></p>
<h1><a class="anchor" id="bones"></a>
Bones</h1>
<p>A mesh may have a set of bones in the form of aiBone structures.. Bones are a means to deform a mesh according to the movement of a skeleton. Each bone has a name and a set of vertices on which it has influence. Its offset matrix declares the transformation needed to transform from mesh space to the local space of this bone.</p>
<p>Using the bones name you can find the corresponding node in the node hierarchy. This node in relation to the other bones' nodes defines the skeleton of the mesh. Unfortunately there might also be nodes which are not used by a bone in the mesh, but still affect the pose of the skeleton because they have child nodes which are bones. So when creating the skeleton hierarchy for a mesh I suggest the following method:</p>
<p>a) Create a map or a similar container to store which nodes are necessary for the skeleton. Pre-initialise it for all nodes with a "no". <br />
 b) For each bone in the mesh: <br />
 b1) Find the corresponding node in the scene's hierarchy by comparing their names. <br />
 b2) Mark this node as "yes" in the necessityMap. <br />
 b3) Mark all of its parents the same way until you 1) find the mesh's node or 2) the parent of the mesh's node. <br />
 c) Recursively iterate over the node hierarchy <br />
 c1) If the node is marked as necessary, copy it into the skeleton and check its children <br />
 c2) If the node is marked as not necessary, skip it and do not iterate over its children. <br />
</p>
<p>Reasons: you need all the parent nodes to keep the transformation chain intact. Depending on the file format and the modelling package the node hierarchy of the skeleton is either a child of the mesh node or a sibling of the mesh node. Therefore b3) stops at both the mesh's node and the mesh's node's parent. The node closest to the root node is your skeleton root, from there you start copying the hierarchy. You can skip every branch without a node being a bone in the mesh - that's why the algorithm skips the whole branch if the node is marked as "not necessary".</p>
<p>You should now have a mesh in your engine with a skeleton that is a subset of the imported hierarchy.</p>
<h1><a class="anchor" id="anims"></a>
Animations</h1>
<p>An imported scene may contain zero to x aiAnimation entries. An animation in this context is a set of keyframe sequences where each sequence describes the orientation of a single node in the hierarchy over a limited time span. Animations of this kind are usually used to animate the skeleton of a skinned mesh, but there are other uses as well.</p>
<p>An aiAnimation has a duration. The duration as well as all time stamps are given in ticks. To get the correct timing, all time stamp thus have to be divided by aiAnimation::mTicksPerSecond. Beware, though, that certain combinations of file format and exporter don't always store this information in the exported file. In this case, mTicksPerSecond is set to 0 to indicate the lack of knowledge.</p>
<p>The aiAnimation consists of a series of aiNodeAnim's. Each bone animation affects a single node in the node hierarchy only, the name specifying which node is affected. For this node the structure stores three separate key sequences: a vector key sequence for the position, a quaternion key sequence for the rotation and another vector key sequence for the scaling. All 3d data is local to the coordinate space of the node's parent, that means in the same space as the node's transformation matrix. There might be cases where animation tracks refer to a non-existent node by their name, but this should not be the case in your every-day data.</p>
<p>To apply such an animation you need to identify the animation tracks that refer to actual bones in your mesh. Then for every track: <br />
 a) Find the keys that lay right before the current anim time. <br />
 b) Optional: interpolate between these and the following keys. <br />
 c) Combine the calculated position, rotation and scaling to a tranformation matrix <br />
 d) Set the affected node's transformation to the calculated matrix. <br />
</p>
<p>If you need hints on how to convert to or from quaternions, have a look at the <a href="http://www.j3d.org/matrix_faq/matrfaq_latest.html">Matrix&amp;Quaternion FAQ</a>. I suggest using logarithmic interpolation for the scaling keys if you happen to need them - usually you don't need them at all.</p>
<h1><a class="anchor" id="textures"></a>
Textures</h1>
<p>Normally textures used by assets are stored in separate files, however, there are file formats embedding their textures directly into the model file. Such textures are loaded into an aiTexture structure. <br />
 There are two cases: <br />
 <b>1)</b> The texture is NOT compressed. Its color data is directly stored in the aiTexture structure as an array of aiTexture::mWidth * aiTexture::mHeight aiTexel structures. Each aiTexel represents a pixel (or "texel") of the texture image. The color data is stored in an unsigned RGBA8888 format, which can be easily used for both Direct3D and OpenGL (swizzling the order of the color components might be necessary). RGBA8888 has been chosen because it is well-known, easy to use and natively supported by nearly all graphics APIs. <br />
 <b>2)</b> This applies if aiTexture::mHeight == 0 is fullfilled. Then, texture is stored in a "compressed" format such as DDS or PNG. The term "compressed" does not mean that the texture data must actually be compressed, however the texture was found in the model file as if it was stored in a separate file on the harddisk. Appropriate decoders (such as libjpeg, libpng, D3DX, DevIL) are required to load theses textures. aiTexture::mWidth specifies the size of the texture data in bytes, aiTexture::pcData is a pointer to the raw image data and aiTexture::achFormatHint is either zeroed or contains the most common file extension of the embedded texture's format. This value is only set if ASSIMP is able to determine the file format. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 9 2015 13:37:58 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
